% INITIAL PROPOSAL CONTENTS

% Your initial proposal should be one page.  It should describe the
% following:
%
% o Project/paper topic.
%                        This should be described by saying what
%                        question your project is going to answer.
\documentclass[letterpaper]{article}
\usepackage{multirow}
\usepackage{fullpage}
\begin{document}
\title{Design and Development of a Verified Peep-hole Optimizer for CompCert}

\author{Thomas M. Du{B}uisson, Andrew Sackville-West}
\maketitle

\section{Introduction}
Modern compilers are so focused on performance and portability that
correctness is almost a second class citizen.  When looking only at
the GNU Compiler Collection and Low Level Virtual Machine projects,
the CSmith project~\cite{Yang11} discovered over 325 bugs where the
compilers would produce incorrectly behaving programs.

Fortunately a compiler was developed with the opposite priorities; the
CompCert~\cite{Leroy-backend} compiler uses a computer assisted theorem
prover to ensure its compiler is correct.  The downside to CompCert is
performance.  Even from casual inspection of the resulting
instructions from a CompCert compilation shows there is clearly
``low-hanging fruit'' -- opportunities to notably improve performance.

There are several opportunities in a compiler to add optimizations. We
propose to add a provably correct peep-hole optimizer to the last
stage of CompCert compilation, the stage in which individual assembly
instructions are selected. In the current versions of the CompCert
compiler, the readily available intermediate stages are at a
relatively high level of abstraction, preventing easy access to the
generated code to perform these types of optimizations. The next
highest level above the assembly code generation, called Mach, likely
has some opportunities for peep-hole optimization, but currently lacks
infrastructure for examining concrete code for discovery of the
specific optimizations to implement. Further, we see significant
differences between the code generated by the various back-ends
suggesting that significant sources of optimization would still remain
in the respective back-ends even after making an optimization pass
over the Mach code. For ease of development, we will target the x86
CompCert back-end.

\section{Approach}
% o Approach.  Are you doing experimental comparison, implementation,
%              or a research paper survey?  What methodology will you
%              use?

A variety of techniques are proposed for translation validation --
{\it a posteriori} validation of the results of a program
transformation \cite{2008-Tristan-Leroy-POPL}. The register allocation
work done by Rideau and Leroy~\cite{Rideau-Leroy-regalloc} utilizes
translation validation in the existing implementation of the CompCert
compiler and provides a rough guideline for how to proceed in the
process. Our first area of investigation will be an attempt to
validate the transformation of assembly code made by an untrusted
peep-hole optimizer written in Caml.  The CompCert framework will run
the untrusted optimizer on x86 assembly code to acquire a {\it
  possibly correct} optimization.  Our CompCert additions will attempt
to prove the optimized assembly has the same semantic meaning as the
input provided to the optimizer via symbolic execution of optimized
and unoptimized assembly code and subsequent comparison of the final
states of execution. A failure to prove the semantic correctness
results in the non-optimized assembly being used for the final
compilation.

\section{Deliverables}
% o Deliverables.  What do you plan to hand in?  Just a paper?
%                  Experimental results? Code?
There are three main deliverables: a method of proving two snippets of
assembly code have the same semantic meaning, an implementation of the
proof in the CompCert framework, and a peep-hole optimizer in
Caml. Additionally, we will provide experimental evidence that the
optimizations attempted have a measurable impact on the performance of
programs.  The fact that the actual transformation is an optimizer (vs
an obfuscation, or a restructuring \`a la Native Client) is expected
to be immaterial to the proof method; as a result, the optimizer will
likely consist of relatively few, trivial transformations of the type
shown in Table \ref{x86}.  Should this technique prove tractable, then
additional optimizations can be added to the untrusted Caml code

\begin{table}
  \caption{Initial x86 peep-hole optimizations}
  \label{x86}
  \begin{center}
  \begin{tabular}{l | l }
    Unoptimized & Optimized\\
    \hline \\
    movl    \%edx, 0(\%esp) &  \multirow{2}{*}{ movl    \%edx,
      0(\%esp)} \\
    movl    0(\%esp), \%edx & \\
    \hline \\
    leal 0(,\%eax,2), \%eax  & add \%eax,  \%eax 
  \end{tabular}
  \end{center}
\end{table}

\bibliography{Proposal}{}
\bibliographystyle{plain}

\end{document}
